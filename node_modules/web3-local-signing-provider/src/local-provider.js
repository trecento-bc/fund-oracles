const Web3 = require('web3')
var BN = require('bn.js')
/**
 * HttpProvider should be used to send rpc calls over http
 */
var LocalProvider = function LocalProvider(hexPrivateKey, provider) {
  this.hexPrivateKey = hexPrivateKey
  this.host = provider.host
  this.timeout = provider.timeout
  this.connected = provider.connected
  this.headers = provider.headers
  this.provider = provider
  this.web3 = new Web3(this)
  this.prepareQueue = []

  if (!Array.isArray(hexPrivateKey)) {
    hexPrivateKey = [hexPrivateKey]
  }

  // add accounts
  this.accounts = {}
  hexPrivateKey.forEach((pk) => {
    var account = this.web3.eth.accounts.privateKeyToAccount(this.add0x(pk))
    this.accounts[account.address.toLowerCase()] = account
  })
  this.web3.eth.defaultAccount = this.accounts[Object.keys(this.accounts)[0]].address
  this.nonces = {}
}

LocalProvider.prototype.add0x = (input) => {
  if (typeof(input) !== 'string') {
    return input
  } else if (input.length < 2 || input.slice(0, 2) !== '0x') {
    return '0x' + input
  }
  return input
}

LocalProvider.prototype.getNonce = function (tx) {
  if (!tx.nonce) {
    if (this.nonces[tx.from]) {
      tx.nonce = this.add0x(new BN(++this.nonces[tx.from]).toString(16))
    } else {
      var self = this
      return self.web3.eth.getTransactionCount(tx.from)
        .then((txCount) => {
          self.nonces[tx.from] = txCount
          tx.nonce = self.add0x(new BN(self.nonces[tx.from]).toString(16))
          return tx
        })
    }
  }
  return Promise.resolve(tx)
}

LocalProvider.prototype.estimateGas = function (tx) {
  const self = this
  if(tx.gas) return Promise.resolve(tx.gas)
  return self.web3.eth.getBlock("latest")
    .then(block => {
      return self.web3.eth.estimateGas(tx)
        .then(gasEstimate => {
          return Math.min(block.gasLimit, gasEstimate * 1.2 * 0.99)
        })
    })
}

/**
 * Should be used to make async request
 *
 * @method send
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
LocalProvider.prototype._callback = function (err, payload, callback) {
  //now that the transaction is done remove it from the queue and call the next one
  // if there are any left
  this.prepareQueue.shift()
  if (this.prepareQueue.length >= 1) this.prepareQueue[0]()
  callback(err, payload)

}

LocalProvider.prototype.send = function (payload, callback) {
  let self = this
  if (payload && (payload.method !== 'eth_sendTransaction' ||
      (payload.method === 'eth_sendTransaction' && !this.accounts[payload.params[0].from]))) {
    self.provider.send(payload, callback)
  } else {
    self.prepareQueue.push(() => {
        self.getNonce(payload.params[0])
          .then((tx) => {
            return Promise.all([tx, self.estimateGas(tx)])
          })
          .then((res) => {
            var tx = res[0]
            tx.gas = tx.gas || self.add0x(new BN(res[1]).toString(16))
            return self.web3.eth.accounts.signTransaction(tx, self.accounts[tx.from].privateKey)
          })
          .then(signedTx => self.web3.eth.sendSignedTransaction(signedTx.rawTransaction, (err, tx) => {
            self._callback(err, {
              "id": payload.id,
              "jsonrpc": "2.0",
              "result": tx
            }, callback)
          }))
          .catch((err) => {
            //if the nonce was increased internally it must be decreased in case of error
            if(self.nonces[payload.params[0].from]) --self.nonces[payload.params[0].from]
            self._callback(err, {
              "id": payload.id,
              "jsonrpc": "2.0",
              "result": {}
            }, callback)
          })
      }
    )
    //the queue is used to avoid creating a transaction before the previous one is done
    //this can happen when transactions are sent in a loop
    if (self.prepareQueue.length === 1) self.prepareQueue[0]()
  }
}

module.exports = LocalProvider
