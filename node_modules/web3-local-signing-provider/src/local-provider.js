const Web3 = require('web3')
var BN = require('bn.js')
/**
 * HttpProvider should be used to send rpc calls over http
 */
var LocalProvider = function LocalProvider(hexPrivateKey, provider) {
  this.hexPrivateKey = hexPrivateKey
  this.host = provider.host
  this.timeout = provider.timeout
  this.connected = provider.connected
  this.headers = provider.headers
  this.provider = provider
  this.web3 = new Web3(this)

  if (!Array.isArray(hexPrivateKey)) {
    hexPrivateKey = [hexPrivateKey]
  }

  // add accounts
  this.accounts = {}
  hexPrivateKey.forEach((pk) => {
    var account = this.web3.eth.accounts.privateKeyToAccount(this.add0x(pk))
    this.accounts[account.address.toLowerCase()] = account
  })
  this.web3.eth.defaultAccount = this.accounts[Object.keys(this.accounts)[0]].address
  this.nonces = {}
}

LocalProvider.prototype.add0x = (input) => {
  if (typeof(input) !== 'string') {
    return input
  } else if (input.length < 2 || input.slice(0, 2) !== '0x') {
    return '0x' + input
  }
  return input
}

LocalProvider.prototype.getNonce = function (tx) {
  if (!tx.nonce) {
    if (this.nonces[tx.from]) {
      tx.nonce = this.add0x(new BN(++this.nonces[tx.from]).toString(16))
    } else {
      var self = this
      return self.web3.eth.getTransactionCount(tx.from)
        .then((txCount) => {
          self.nonces[tx.from] = txCount
          tx.nonce = self.add0x(new BN(self.nonces[tx.from]).toString(16))
          return tx
        })
    }
  }
  return Promise.resolve(tx)
}

LocalProvider.prototype.estimateGas = function (tx) {
  const self = this
  if(tx.gas) return Promise.resolve(tx.gas)
  return self.web3.eth.getBlock("latest")
    .then(block => {
      return self.web3.eth.estimateGas(tx)
        .then(gasEstimate => {
          return Math.min(block.gasLimit, gasEstimate * 1.2 * 0.99)
        })
    })
}

/**
 * Should be used to make async request
 *
 * @method send
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
LocalProvider.prototype.send = function (payload, callback) {
  let self = this
  if (payload && payload.method !== 'eth_sendTransaction') {
    self.provider.send(payload, callback)
  } else {
    self.getNonce(payload.params[0])
      .then((tx) => {
        return Promise.all([tx, self.estimateGas(tx)])
      })
      .then((res) => {
        var tx = res[0]
        tx.gas = tx.gas || self.add0x(new BN(res[1]).toString(16))
        return self.web3.eth.accounts.signTransaction(tx, self.accounts[tx.from].privateKey)
      })
      .then(signedTx => self.web3.eth.sendSignedTransaction(signedTx.rawTransaction, (err, tx) => {
        callback(err, {
          "id": payload.id,
          "jsonrpc": "2.0",
          "result": tx
        })
      }))
      .catch(callback)
  }
}

module.exports = LocalProvider
